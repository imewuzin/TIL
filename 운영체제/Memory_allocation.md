# 연속 메모리 할당

: 프로세스들이 메모리 내에서 연속적으로 할당되는 방식

- **스와핑**  
  : 현재 사용되지 않는 프로세스들을 보조기억 장치의 일부 영역(스왑 영역)으로 옮기고, 그렇게 생긴 빈 메모리 공간에 새로운 프로세스를 적재하는 방식
  
  - 실제 메모리보다 큰 프로세스들을 동시에 실행 가능
  
  - ex) 프로세스 A, B, C, D가 동시에 실행되길 원하나, 이들의 총 크기가 물리 메모리보다 큰 경우 -> 프로세스 A, B, C를 메모리에 적재한 후, 프로세스 D를 실행해야 한다면, 프로세스 B를 스압 아웃시키고 프로세스 D를 적재 ->  프로세스 B가 다시 필요하면, 수압 영역에서 B를 다시 불러오고, 다른 프로세스를 스왑 아웃시키는 방식으로 처리

- **연속 메모리 할당 방식**  
  
  1. **최초 적합(First-Fit)**
     
     : 운영체제가 빈 공간을 순서대로 검색하다가 적합한 공간을 발견하면 그곳에 프로세스를 배치
     
     - 검색 시간이 짧고 빠르게 할당
  
  2. **최적 적합(Best-Fit)**
     
     : 빈 공간을 모두 검색한 후, 적재할 프로세스와 가장 잘 맞는 가장 작은 빈 공간에 할당
     
     - 메모리 공간을 효율적으로 사용하지만, 검색 시간이 길어질 수 있음
  
  3. **최악 적합(Worst-Fit)**
     
     : 빈 공간을 모두 검색한 후, 가장 큰 빈 공간에 프로세스를 할당
     
     - 큰 공간을 할당하여 외부 단편화를 줄이지만, 자주 빈 공간이 남을 수 있음

- **외부 단편화**  
  : 메모리 내의 빈 공간이 흩어져 있어, 큰 프로세스를 적재할 수 없는 경우
  
  - 해결 방법
    
    1. **메모리 압축(Compaction)**
       
       : 흩어져 있는 빈 공간들을 하나로 모아 큰 빈 공간을 만드는 방식
       
       - 오버헤드가 크고, 프로세스 재배치로 인해 성능 저하가 발생 가능
    
    2. <mark>**페이징 (Paging)**</mark>

---

## 페이징

: 가상 메모리 관리 기법 중 하나로, 프로세스의 논리 주소 공간을 일정한 크기의 **페이지**로 나누고, 물리 주소 공간도 같은 크기의 **프레임**으로 나누어 페이지를 프레임에 할당하는 방식

- 현대 운영체제에서 외부 단편화를 최소화하기 위해 사용하는 방식

- 페이징에서의 스와핑
  
  - 프로세스 단위의 스왑 인, 스왑 아웃이 아닌 페이지 단위의 스왑 인(페이지 인), 스왑 아웃(페이지 아웃)
  
  - 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃
  
  - 실행에 필요한 페이지들은 메모리로 스왑 인

- 특징
  
  - 외부 단편화 문제 해결 (장점)
    
    : 프로세스를 일정 크기의 페이지로 나누어 불연속적으로 메모리에 배치함으로써 외부 단편화 문제를 해결
  
  - 내부 단편화 (단점)
    
    : 각 페이지 크기보다 작은 메모리 부분이 낭비될 수 있으며, 이로 인해 내부 단편화가 발생 가능(외부 단편화보다 상대적으로 덜 심각)

- 페이지 테이블 (Page Table)
  : 논리 주소를 물리 주소로 변환하는 데 필요한 정보를 저장
  
  - 페이지 번호와 프레임 번호를 짝지어 주는 일정의 이정표
  
  - (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 하는 방법
  
  - 각 프로세스마다 페이지 테이블이 있으며, 어떤 페이지가 어떤 프레임에 매핑되는지를 나타냄

- 프로세스 테이블 베이스 레지스터(PTBR)
  : 각 프로세스의 페이지 테이블의 주소를 가리키는 CPU 내의 레지스터
  
  - 페이지 테이블이 있으면 메모리 접근 시간이 2배로 늘어날 수 있음(페이지 테이블을 참조하기 위해 1번, 페이지를 참조하기 위해 1번)

- TLB(Translation Lookaside Buffer)
  
  : CPU 곁에 페이지 테이블의 캐시 메모리. 페이지 테이블의 일부를 가져와 저장
  
  - 페이지 테이블의 일부를 캐싱하여 메모리 접근 시간을 단축시키는 캐시 메모리
  
  - TLB 히트 : CPU가 접근하려는 논리주소가 TBL에 있음. 메모리 접근 빠름
  
  - TLB 미스 : CPU가 접근하려는 논리주소가 TBL에 없음. 메모리에 두 번 접근하게 됨

- 주소 변환 과정
  
  - `<페이지 번호, 변위>`로 이루어진 논리 주소는 페이지 번호를 통해 페이지 테이블을 참조하여 물리 주소`<프레임 번호, 변위>`로 변환
  
  - 논리 주소와 물리 주소의 변위는 같음
  
  - 물리 주소 : 페이지 테이블에서 얻은 프레임 번호와 페이지 오프셋을 결합하여 최종 물리 주소 생성

- 페이지 테이블 엔트리(PTE)
  
  : 페이지 테이블 각각의 행
  
  - 구성
    
    - 유효 비트 : 현재 해당 페이지에 접근 가능한지 여부를 알려주는 비트
      
      - 유효비트가 0인 페이지에 접근하려고 하면 페이지 폴트(page fault)라는 인터럽트 발생
    
    - 보호 비트 : 페이지에 접근할 권한을 제한해 페이지를 보호하는 비트
    
    - 참조 비트 : CPU가 이 페이지에 접근한 적이 있는지 여부를 알려주는 비트
    
    - 수정 비트(=dirty bit) : CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부를 알려주는 비트

- cf. 가상메모리
  
  : 실행하고자 하는 프로그램을 일부만 메모리에 적재해 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
  
  - 페이지, 세그멘테이션

---

## 쓰기 시 복사

: 부모 프로세스와 동일한 자식 프로세스가 복제되어 생성되면, 자식 프로세스는 부모 프로세스와 동일한 프레임을 가리킴 (쓰기 작업이 없다면 이 상태 유지)

: 부모 프로세스 / 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업 수행 시 해당 페이지는 별도의 공간으로 복제 (프로세스 생성 시간 절약, 메모리 절약)

- 이론적인 `fork()`
  
  - 프로세스는 기본적으로 자원을 공유하지 않음
  
  - 부모 프로세스가 적재된 별도의 공간에 자식 프로세스가 통째로 복제되어 적재
  
  - 프로세스 생성 시간 지연, 메모리 낭비

## 계층적 페이징

: 페이지 테이블을 페이징하여 여러 단계의 페이지 페이지를 두는 방식

: 페이지 테이블을 여러 페이지로 쪼개고, 이 페이지를 가리키는 페이지 테이블(Outer 페이지 테이블)을 두는 방식

- 프로세스 테이블의 크기는 생각보다 작지 않음

- 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 낭비

- 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 방법

- 계층적 페이징을 이용하는 환경에서의 논리 주소
  
  - 바깥 페이지 번호, 안쪽 페이지 번호, 변위
  1. 바깥 페이지 번호를 통해 페이지 테이블의 페이지를 찾기
  
  2. 페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더함으로서 물리 주소 얻기

- 계층이 많다고 반드시 좋다고 할 수 없음

---

## 페이지 교체 알고리즘 및 프레임 할당

- 운영 체제는 기존에 적재된 불필요한 페이지를 선별해 보조기억장치로 내보내고(페이지 교체 알고리즘), 프로세스들에게 적절한 수의 프레임을 할당해야 함(프레임 할당)

- #### 요구 페이징
  
  : 처음부터 모든 페이지를 적재하지 않고 필요한(요구되는) 페이지만을 메모리에 적재하는 기법
  
  - 요구 페이징이 안정적으로 작동하려면 페이지 교체와 프레임 할당이 해결되어야 함
  
  - 실행 방법
    
    1.  CPU가 특정 페이지에 접근하는 명령어를 실행
    
    2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근
    
    3. 해당 페이지가 현재 메모리에 없을 경우(유효 비트가 0일 경우) 페이지 폴트 발생
    
    4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리에 적재하고 유효 비트를 1로 설정
    
    5. 다시 1번을 수행

- ### 페이지 교체 알고리즘
  
  : 요구 페이징 기법으로 페이지들을 적재하다 보면 언젠가 메모리가 가득 차게 되기 때문에, 당장 실행에 필요한 페이지를 적재하기 위해 보조기억장치로 보낼 페이지를 결정하는 알고리즘
  
  - 좋은 페이지 교체 알고리즘
    
    - 페이지 폴트가 적은 알고리즘 : 페이지 폴트가 발생하면 보조기억장치에 접근해야 해서 성능 저하
  
  - 페이지 참조열 (page reference string)
    
    : CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열
  
  - ##### FIFO (First-In, First-Out) 페이지 교체 알고리즘
    
    : 가장 먼저 들어온 페이지를 가장 먼저 교체하는 방식
    
    - 페이지가 메모리에 들어온 순서대로 유지되고, 교체가 필요할 때 가장 오래된 페이지가 제거됨
    
    - 예시
      
      > - 프로세스가 사용할 수 있는 프레임이 3개일 때 페이지 참조 순서가 `1, 2, 3, 4, 1, 2, 5`인 경우
      > 1. `1`: 페이지 폴트 발생 → `1` 적재
      > 
      > 2. `2`: 페이지 폴트 발생 → `2` 적재
      > 
      > 3. `3`: 페이지 폴트 발생 → `3` 적재
      > 
      > 4. `4`: 페이지 폴트 발생 → `1` 제거 후 `4` 적재
      > 
      > 5. `1`: 페이지 히트 발생
      > 
      > 6. `2`: 페이지 히트 발생
      > 
      > 7. `5`: 페이지 폴트 발생 → `2` 제거 후 `5` 적재
    
    - 장점 : 구현이 간단하고 이해하기 쉬움
    
    - 단점 : 성능이 좋지 않을 수 있음, 페이지 폴트가 많아질 가능성
    
    - 보완책 - **2차  기회(second-chance) 페이지 교체 알고리즘**
      
      - 참조 비트 1 : CPU가 한 번 참조한 적이 있는 페이지 (한번 더 기회 주기 - 참조 비트 0으로 초기화 후 적재 시간을 현재 시간으로 설정)
      
      - 참조 비트 0 : CPU가 참조한 적이 없는 페이지 (내쫒기)
  
  - ##### 최적 페이지 교체 알고리즘
    
    : 다음에 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식
    
    - 예시
      
      > - 프로세스가 사용할 수 있는 프레임이 3개, 페이지 참조 순서가 `2, 3, 1, 3, 5, 2, 3, 4, 2, 3`인 경우
      > 1. 페이지 참조: 2, 3, 1, 5
      > 
      > 2. 페이지 폴트 발생: 2, 3, 1이 적재됨
      > 
      > 3. 페이지 참조: 5에서 2와 3 중 1번 페이지가 가장 오랫동안 사용되지 않을 것으로 판단, 1번 페이지를 교체
      > 
      > 4. 페이지 참조: 2, 3, 5에서 또 다시 5번 페이지 폴트가 발생하면 2와 3 중 5번이 가장 오랫동안 사용되지 않으므로 5번 페이지를 교체
    
    - 페이지 폴트 빈도를 줄일 수 있으나, 실제 구현이 어렵고 이론적 성능 평가에 주로 사용됨 (하한선으로 간주)
  
  - ##### LRU (Least Recently Used) 페이지 교체 알고리즘
    
    : 가장 최근에 사용되지 않은 페이지를 교체하는 방식
    
    - 예시
      
      > - 프로세스가 사용할 수 있는 프레임이 3개, 페이지 참조 순서가 `2, 3, 1, 3, 5, 2, 3, 4, 2, 3`인 경우
      > 1. 페이지 참조: 2, 3, 1 (모두 적재)
      > 
      > 2. 페이지 참조: 5에서 페이지 폴트 발생, 2번 페이지 교체
      > 
      > 3. 페이지 참조: 2에서 페이지 폴트 발생, 1번 페이지 교체
    
    - 실제 사용에 적합하며, 다양한 변형 알고리즘 존재

- ### 스레싱 (Thrashing)
  
  : 프로세스가 실행되는 시간보다 페이지 교체에 소요되는 시간이 실행 시간보다 많아져 CPU 이용률이 저하되는 현상
  
  - 원인 : 프로세스에 할당된 프레임 수가 부족한 경우
  
  - 동시 실행되는 프로세스의 수를 늘린다고 CPU 이용률이 높아지는 것은 아님
  
  - 프레임 수가 적으면 페이지 폴트가 자주 발생하여 메모리 여유가 있을수록 페이지 폴트 발생 빈도 감소

- ### 프레임 할당 방식
  
  - ##### 균등 할당 (Equal Allocation) - 정적 할당
    
    : 모든 프로세스에 동일한 수의 프레임을 할당
    
    - ex) 300개의 프레임이 있는 시스템에서 3개 프로세스라면 각 100개 할당
  
  - ##### 비례 할당 (Proportional Allocation) - 정적 할당
    
    : 프로세스 크기에 비례하여 프레임을 할당
    
    - 실제 실행 시 필요 프레임 수는 변동이 있을 수 있음
  
  - ##### 작업 집합 모델 (Working Set Model) - 동적 할당
    
    : 특정 시간 동안 참조한 페이지 수만큼 프레임을 할당
    
    - 프로세스의 참조 지역성 원리에 기반
    
    - 특정 시간 동안 7개의 페이지를 참조했다면 7개의 프레임을 할당
    
    - 작업 집합 : 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합
    
    - 작업 집합 구하려면 프로세스가 참조한 페이지, 시간 간격 필요
  
  - ##### 페이지 폴트 빈도 기반 할당 - 동적 할당
    
    : 페이지 폴트율에 따라 프레임 수를 조정
    
    - 2개의 가정에서 생겨난 아이디어
      
      - 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임이 할당됨
      
      - 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임이 할당됨
    
    - 페이지 폴트율이 높으면 프레임을 추가하고, 낮으면 회수
