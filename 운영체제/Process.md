# 프로세스

: 실행 중인 프로그램

- 직접 확인 하는 법
  
  - 윈도우 : `작업관리자`
  
  - 리눅스, macOS : `ps 명령어` ex) `ps -ef`

- 프로세스 종류
  
  - 포그라운드 프로세스(Foreground Process)
    
    - 사용자가 볼 수 있는 공간에서 실행되는 프로세스
    
    - ex) 메모장, 게임, 웹 브라우저 등
  
  - 백그라운드 프로세스(Background Process)
    
    - 사용자가 볼 수 없는 공간에서 실행되는 프로세스
    
    - 종류  
      
      - **데몬(daemon), 서비스(service)** : 사용자와 직접 상호작용이 가능한 백그라운드 프로세스
      
      - 사용자와 상호작용하지 않고 그저 정해진 일만 수행하는 프로세스

- #### 프로세스 제어 블록 (PCB) - 커널 영역
  
  : 빠르게 번갈아 수행되는 프로세스들을 관리하기 위한 자료구조
  
  : 상품에 달린 태그와 같이 프로세스 관련 정보를 저장하는 자료구조
  
  : 프로세스 생성 시 **커널 영역**에 생성, 종료 시 폐기
  
  - 모든 프로세스는 실행을 위해 CPU가 필요 -> CPU 자원은 한정됨
  
  - 프로세스들은 돌아가며 한정된 시간만큼만 CPU 사용
    
    - 자신의 차례에 정해진 시간만큼 CPU 이용 -> 타이머 인터럽트 발생하면 차례 양보
    
    - 타이머 인터럽트 : 주기적으로 발생하는 하드웨어 인터럽트의 한 종류. 타임아웃 인터럽트라 하기도 함
  
  - PCD에 담기는 대표적인 정보
    
    - 프로세스 ID(=PID)
      
      - 특정 프로세스를 식별하기 위해 부여하는 고유한 번호 (학교의 학번, 회사의 사번)
      
      - 윈도우 : `작업 관리자` -> `'프로세스` -> 마우스 우클릭 -> `프로세스 이름` 으로 확인 가능
    
    - 레지스터 값
      
      - 프로세스는 자신의 실행 차례가 오면 이전까지 사용한 레지스터 중간 값을 모두 복원 -> 실행 제계
      
      - 레지스터 중간값 : 프로그램 카운터, 스택 포인터 등
    
    - 프로세스 상태
      
      - 입출력 장치를 사용하기 위해 기다리는 상태, CPU를 사용하기 위해 기다리는 상태, CPU 이용중인 상태 등
    
    - CPU 스케줄링 정보
      
      - 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
    
    - 메모리 정보
      
      - 프로세스가 현재 메모리의 어느 주소에 저장되어 있는지에 대한 정보
      
      - 페이지 테이블 정보 : 메모리의 현재 주소를 알 수 있는 정보(추가 공부 예정)
    
    - 사용한 파일과 입출력장치 정보
      
      - 할당된 입출력장치, 사용 중인(열린) 파일 정보

- #### 문맥 교환 (Context switch)
  
  : 기존의 실행 중인 프로세스 문맥을 백업하고, 새로운 프로세스 실행을 위해 문맥을 복구하는 과정
  
  : 여러 프로세스가 끊임없이 빠르게 번갈아가며 실행되는 원리
  
  - 한 프로세스에서 다음 프로세스로 실행순서 넘어가면 
    
    1. 기존에 실행되던 프로세스는 지금까지의 **중간 정보(문맥)** 백업
       
       - 프로그램 카운터 등 각종 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력장치 등
       
       - 다음 차례가 왔을 때 실행을 재개하기 위한 정보
       
       - 실행 문맥을 백업해두면 언제든 해당 프로세스의 실행을 재개할 수 있음
    
    2. 다음 프로세스의 문맥 복구
       
       - 자연스럽게 실행 중인 프로세스 바뀜

- #### 프로세스의 사용자 영역 (메모리 : 커널 영역 + 사용자 영역)
  
  - 정적 할당 영역 (크기가 고정된 영역)
    
    - 코드 영역 (= 텍스트 영역)
      
      - 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
      
      - 데이터가 아닌 CPU가 실행할 명령어가 담기기에 쓰기가 금지된 영역 (Read-only)
    
    - 데이터 영역
      
      - 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터 저장
      
      - ex) 전역 변수
  
  - 동적 할당 영역 (크기 가변적)
    
    - 힙 영역
      
      - 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장공간
      
      - 가비지 컬렉션(Gabage Collection) : 언젠가는 힙 영역에 할당한 메모리 공간을 반환해야 하는데, 프로그래밍 언어가 알아서 반환해주는 것. (C언어는 이 기능 없어서 일일이 반환해야 함)
      
      - 메모리 누수(Memory Leak) : 힙 영역에 할당한 메모리를 반환하지 않아 메모리를 낭비하는 것
      
      - 일반적으로 낮은 주소 -> 높은 주소 할당
    
    - 스택 영역
      
      - 데이터가 일시적으로 저장되는 공간
      
      - (데이터 영역에 담기는 값과는 달리) 잠깐 쓰다가 말 값들이 저장되는 공간
      
      - ex) 매개 변수, 지역 변수
      
      - 일반적으로 높은 주소 -> 낮은 주소 할당

---

## 프로세스 상태

- 윈도우 : `작업 관리자` -> `세부 정보` -> `상태` 에서 PCB에 기록되는 프로세스 상태 확인 가능

- ###### 생성 상태
  
  - 이제 막 메모리에 적재되어 PCB를 할당받은 상태
  
  - 준비가 완료되었다면 준비 상태로

- ###### 준비 상태
  
  - 당장이라도 CPU를 할당받아 실행할 수 있지만, 자신의 차례가 이니기에 기다리는 상태
  
  - 자신의 차례가 된다면 실행 상태로 (디스패치)

- ###### 실행 상태 (= Running state)
  
  - CPU를 할당 받아 실행중인 상태
  
  - 할당된 시간 모두 사용 시(타이머 인터럽트 발생 시) 준비 상태로
  
  - 실행 도중 입출력장치를 사용하면 입출력 작업이 끝날 때까지(입출력 완료 인터럽트를 받을 때까지) 대기상태로

- ###### 대기 상태 (=Block state)
  
  - 프로세스가 실행 도중 입출력장치를 사용하는 경우
  
  - 입출력 작업은 CPU에 비해 느리기에 이 경우 대기 상태로
  
  - 입출력 작업이 끝나면(입출력 완료 인터럽트를 받으면) 준비 상태로

- ###### 종료 상태
  
  - 프로세스가 종료된 상태
  
  - PCB, 프로세스의 메모리 영역 정리

![프로세스 상태 다이어그램](https://github.com/user-attachments/assets/50843925-211a-4561-8c97-b882a4090750)

---

## 프로세스 계층 구조

- 프로세스 실행 도중 (시스템 호출을 통해) 다른 프로세스 생성 가능

- 윈도우는 프로세스 계층 구조를 이용해 관리하지는 않음

- **부모 / 자식 프로세스**
  
  - 부모 프로세스 : 새 프로세스를 생성한 프로세스
  
  - 자식 프로세스 : 부모 프로세스에 의해 생성된 프로세스
  
  - 부모 프로세스와 자식 프로세스는 별개의 프로세스이므로 각기 다른 PID를 가짐
  
  - 일부 운영체제에서는 자식 프로세스 PCB에 부모 프로세스 PID(PPIC)를 명시하기도 함

- 최초의 프로세스 확인하기 (윈도우는 계층 구조 이용 X)
  
  - 리눅스, macOS : `pstree`

- 프로세스 생성 기법 : 복제와 옷 갈아입기
  
  - 부모 프로세스는 `fork` 시스템 호출을 통해 자신의 복사본을 자식 프로세스로 생성
  
  - 자식 프로세스는 `exec` 시스템 호출을 통해 자신의 메모리 공간을 다른 프로그램으로 교체
  
  - `fork` 시스템 호출 : 자기 자신의 복사본 생성. 부모 프로세스의 자원 상속. PID나 저장된 위치는 다음!
  
  - `exec` 시스템 호출 : 메모리 공간을 새로운 프로그램으로 덮어쓰기. 코드/데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화






