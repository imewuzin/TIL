# 동기화

: 프로세스들의 수행 시기를 맞추는 것

- 실행의 문맥을 갖는 모든 대상은 동기화의 대상. 스레드 포함

- 자원의 일관성을 위해 필요

- 주요 개념
  
  - **실행 순서 제어**
    
    : 프로세스를 올바른 순서대로 실행하기
    
    - ex) 데이터베이스에 값을 기록하기 전에 먼저 데이터를 준비해야 할 때, 준비가 완료된 후에만 기록 작업이 수행되도록 보장
  
  - **상호 배제 (Mutual Exclusion)**
    
    : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기
    
    - ex) 하나의 프로세스가 프린터를 사용하고 있을 때, 다른 프로세스가 동시에 사용하지 못하도록 하는 것
    
    - ex) Bank Account Problem
      
      : 두 개의 프로세스 A와 B가 동시에 은행 계좌의 잔액을 읽고 수정하려고 할 때 발생할 수 있는 문제. 만약 동기화가 이루어지지 않으면, 두 프로세스가 같은 초기 잔액을 읽고, 서로의 변경을 덮어쓰게 되어 잘못된 결과를 초래할 수 있음
    
    - ex) Producer-Consumer Problem
      
      : 생산자와 소비자 두 개의 프로세스가 동일한 버퍼를 공유할 때 발생할 수 있는 문제. 생산자는 버퍼에 아이템을 추가하고 소비자는 버퍼에서 아이템을 제거. 동기화가 제대로 이루어지지 않으면 버퍼가 오버플로우되거나 언더플로우될 수 있음

- #### 공유 자원과 임계 구역
  
  - 공유 자원
    
    : 여러 프로세스 혹은 스레드가 공유하는 자원
    
    - ex)  전역 변수, 파일, 입출력장치, 보조기억장치, ...
  
  - 임계 구역
    
    : 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 블록
    
    - ex) 앞선 예시의 '총합' 변수, '잔액' 변수, ...
    
    - 임계 구역에 진입하고자 하면 진입한 프로세스 이외에는 대기해야 함
    
    - 임계 구역 내에서의 작업은 동기화 메커니즘을 통해 보호되어야 함
  
  - **레이스 컨디션 (Race Condition)**
    
    : 임계 구역에 동시에 접근해 자원의 일관성이 깨지는 상황
    
    : 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 실행 순서에 따라 결과가 달라지는 상황
    
    - 동기화가 제대로 이루어지지 않으면 발생할 수 있음
  
  - 운영체제가 임계 구역 문제를 해결하는 3가지 원칙
    
    = 상호 배제를 위한 동기화를 위한 3가지 원칙
    
    1. **상호 배제(mutual exclusion)**
       
       : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 들어올 수 없음
    
    2. **진행(progress)**
       
       : 임계 구역에 어떤 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야 함
    
    3. **유한 대기(bounded waiting)**
       
       : 한 프로세스가 임계구역에 진입하고 싶다면 언젠가는 임계 구역에 들어올 수 있어야 함 (임계 구역에 들어오기 위해 무한정 대기 x)

---

## 동기화 문제의 해결 방법

- #### 뮤텍스 락(Mutex Lock)
  
  : 상호 배제를 위한 동기화 도구(자물쇠 역할)
  
  - 한 번에 하나의 프로세스만이 임계 구역에 접근할 수 있도록 함
  
  - 형태
    
    : 전역 변수 1개, 함수 2개
    
    - 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 `lock`
    
    - 임계 구역을 잠그는 역할 : `acquire` 함수
    
    - 임계 구역의 잠금을 해제하는 역할 : `release` 함수
    
    ```c
    acquire() {
        while (lock == true)   # 만약 임계 구역이 잠겨 있다면
            ;                  # 임계 구역이 잠겨 있는지를 반복적으로 확인
        lock = true;           # 만약 임계 구역이 잠겨 있지 않다면 임계 구역 잠금
    }
    
    release() {
        lock = false;          # 임계 구역 작업이 끝났으니 작업 해제
    }
    ```
  
  - 프로세스가 임계 구역에 진입하기 전에 뮤텍스를 **획득(aquire)** 하고, 작업이 끝난 후에는 뮤텍스를 **반환(release)**
  
  - **`aquire` 함수**
    
    - 프로세스가 임계 구역에 진입하기 전에 호출
    
    - 임계 구역이 잠겨 있다면 임계 구역이 열릴 때까지(`lock`이 `false`가 될 때까지) 임계 구역을 반복적으로 확인
    
    - 임계 구역이 열려 있다면 임계 구역을 잠그기(`lock`을 `true`로 바꾸기)
  
  - **`release` 함수**
    
    - 임계 구역 작업이 끝나고 호출
    - 현재 잠긴 임계 구역을 열기(`lock`을 `false`로 바꾸기)
  
  - 문제점: 반복적으로 임계 구역의 상태를 확인하는 **바쁜 대기(busy waiting)** 발생 가능

- #### 세마포 (Semaphore)
  
  : 조금 더 일반화된 방식의 동기화 도구
  
  : 공유 자원이 여러 개 있는 경우에도 적용 가능
  
  - 세마포는 이진 세마포, 카운팅 세마포가 있지만, 이진 세마포는 뮤텍스 락과 유사하므로 카운팅 세마포를 다룸
  
  - 형태
    
    : 전역 변수 1개, 함수 2개
    
    - 전역 변수 `S` : 임계 구역에 진입할 수 있는 프로세스의 개우(사용가능한 공유 자원의 개수)
    
    - `wait` 함수 : 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 함수
    
    - `signal` 함수 : 임계 구역 앞에서 기다리는 프로세스에 '이제 가도 좋다'고 신호를 주는 함수
    
    ```c
    wait() {
        while (S <= 0)    # 만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면
        ;                 # 사용할 수 있는 자원이 있는지 반복적으로 확인하고
        S--;              # 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 임계 구역 진입
    }
    // 임계구역
    signal() {
        S++               # 임계 구역에서의 작업을 마친 뒤 S를 1 증가
    }
    ```
  
  - **`wait` 함수**
    
    : 공유 자원이 부족하면 대기 상태로 들어감
    
    - 자원이 충분히 있을 경우, 자원을 사용하고 카운터 감소
  
  - **`signal` 함수**
    : 작업을 마친 후 자원을 반환하고 카운터 증가
    
    - 대기 중인 프로세스가 있으면 깨워서 자원을 사용하도록
  
  - 세마포를 활용한 실행 순서 동기화
    
    - 세마포의 변수 `S`를 `0`으로 두고
    
    - 먼저 실행할 프로세스 뒤에 `signal` 함수
    
    - 다음에 실행할 프로세스 앞에 ` wait` 함수 붙이면 됨
  
  - 문제점 : **바쁜 대기(busy waiting)** 문제가 있음 -> CPU 사이클 낭비
  
  - 해결책
    
    - 사용할 수 있는 자원이 없을 경우 **대기 상태**로 만듦(해당 프로세스의 PCB를 대기 큐에 삽입)
    
    - 사용할 수 있는 자원이 생겼을 경우 대기 큐의 프로세스를 **준비 상태**로 만듦(해당 프로세스의 PCB를 대기 큐에서 꺼내 준비 큐에 삽입)

- #### 모니터(Monitor)
  
  : 뮤텍스 락과 세마포의 기능을 결합한 동기화 도구
  
  : 프로세스 간의 상호 배제를 관리하고, 조건 변수를 사용해 실행 순서를 제어
  
  - 상호 배제를 위한 동기화
    
    - 인터페이스를 위한 큐
    
    - 공유 자원에 접근하고자 하는 프로세스를 (인터페이스를 위한) 큐에 삽입
    
    - 큐에 삽입된 순서대로 (한 번에 하나의 프로세스만) 공유 자원 이용
  
  - 실행 순서 제어를 위한 동기화
    
    - 조건 변수 이용
    
    - 조건변수.`wait()` : 대기 상태로 변경. 조건 변수에 대한 큐에 삽입
    
    - 조건변수.`signal()` : `wait()`으로 대기 상태로 접어든 조건 변수를 실행 상태로 변경
    
    - 조건 변수 : 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수
    
    - 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 `wait`를 통해 실행 중단
    
    - 특정 프로세스가 실행될 조건이 충족되었을 때에는 `signal`을 통해 실행 재개
  
  - 모니터 안에는 하나의 프로세스만이 있을 수 있음 - 2가지 방법
    
    1. `wait()`을 호출했던 프로세스는 `signal()`을 호출한 프로세스가 모니터를 떠난 뒤에 수행을 재게
    
    2. `signal()`을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된 뒤, 다시 `signal()`을 호출한 프로세스의 수행을 재게
  
  - 프로세스가 모니터에 접근하기 전에 모니터의 락을 획득하고, 작업이 끝난 후 락을 반환합니다. 조건 변수를 통해 프로세스의 실행 순서를 제어할 수 있습니다.
