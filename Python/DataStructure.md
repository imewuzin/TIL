# 자료구조(Data Structure)

: 여러 데이터를 효과적으로 사용, 관리하기 위한 구조

![자료구조](https://github.com/user-attachments/assets/964be1d3-0b0a-4ea8-9869-7c00ac18690a)

---

## 메서드 method

: 객체(class)에 속한 함수. 객체의 상태를 조작하거나 동작을 수행

- 특징
  
  - 메서트는 클래스(class) 내부에 정의되는 함수
  
  - 클래스 : 파이썬에서 타입을 표현하는 방법 (`help` 함수로 확인 가능)
  
  - 각 데이터 타입별로 다양한 기능을 가진 메서드가 존재
  
  - 모든 메서드는 이어서 사용 가능
    
    > ```python
    > text = 'hello, woRld!'
    > new_text = text.swapcase().replace('l','z')
    > print(new_text)  # HEzzO, WOrLD!
    > ```

- `데이터 타입 객체.메서드()` 형식

---

## 시퀀스 데이터 구조

### 문자열

- 문자열 조회/탐색 및 검증 메서드
  
  | 메서드          | 설명                                         |
  | ------------ | ------------------------------------------ |
  | `.find(x)`   | x의 첫번째 위치 반환. 없으면 -1 반환                    |
  | `.index(x)`  | x의 첫번째 위치 반환. 없으면 오류 발생                    |
  | `.isupper()` | 모두 대문자인지 확인                                |
  | `.islower()` | 모두 소문자인지 확인                                |
  | `.isalpha()` | 알파벳 문자 여부(단순 알파벳이 아닌 유니코드상 Letter. 한국어 포함) |

- 문자열 조작 메서드(새 문자열 반환)
  
  : 문자열은 변경 불가능한 자료형이기 때문에 원본을 조작한 새로운 문자열 반환
  
  | 메서드                             | 설명                                                  |
  | ------------------------------- | --------------------------------------------------- |
  | `.replace(old, new[,count])`    | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환. count에 숫자를 넣지 않으면 전체를 바꿈. |
  | `.strip([chars])`               | 문자열의 시작과 끝에 있는 공백이나 특정 문자 제거                        |
  | `.split(sep=None, maxsplit=-1)` | 공백이나 특정 문자를 기준으로 분리                                 |
  | `'separator'.join(iterable)`    | 구분자(separator)로 iterable의 문자열을 연결한 문자열을 반환          |
  | `.capitalize()`                 | 가장 첫번째 글자를 대문자로 변경. 이후 문자들은 모두 소문자로 변경              |
  | `.title()`                      | 문자열 내 띄어쓰기 기준으로 각 단어의 첫글자는 대문자로, 나머지는 소문자로 반환       |
  | `.upper()`                      | 모두 대문자로 변경                                          |
  | `.lower()`                      | 모두 소문자로 변경                                          |
  | `.swapcase()`                   | 대, 소문자 서로 변경                                        |
  
  > - `.replace(old, new[,count])` 예시
  >   
  >   ```python
  >   text = 'Hello, world! Hello, world'
  >   new_text = text.replace('world', 'Python')
  >   print(new_text)  # Hello, Python! Hello, Python
  >   
  >   text = 'Hello, world! Hello, world'
  >   new_text = text.replace('world', 'Python', 1)
  >   print(new_text)  # Hello, Python! Hello, world
  >   ```

- 문자 유형 판별 메서드
  
  : 문자열에 포함된 문자들의 유형을 판별하는 메서드
  
  | 메서드            | 설명                                                                |
  | -------------- | ----------------------------------------------------------------- |
  | `.isdecimal()` | 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True                                |
  | `.isdigit()`   | `.isdeciaml()`과 비슷하지만 유니코드 숫자도 인식                                 |
  | `.isnumeric()` | `.isdigit()`과 유사하지만 몇가지 추가적인 유니코드 문자들도 인식 (분수, 지수, 루트 기호도 숫자로 인식) |
  
  > 예시
  > 
  > | isdecimal() | isdigit() | isnumeric() | 예시                        |
  > |:-----------:|:---------:|:-----------:|:-------------------------:|
  > | True        | True      | True        | "038",   "੦੩੮",   "０３８"   |
  > | False       | True      | True        | "⁰³⁸", "🄀⒊⒏", "⓪③⑧"      |
  > | False       | False     | True        | "⅛⅘", "ⅠⅢⅧ", "⑩⑬㊿", "壹貳參" |
  > | False       | False     | False       | "abc", "38.0", "-38"      |

### 리스트

- 리스트 값 추가 및 삭제 메서드
  
  | 메서드             | 설명                                                       |
  | --------------- | -------------------------------------------------------- |
  | `.append(x)`    | 리스트 마지막에 항목 x를 추가                                        |
  | `.extend(m)`    | iterable m의 모든 항목들을 리스트 끝에 추가 (`+=`과 같은 기능)              |
  | `.insert(i, x)` | 리스트 인덱스 i에 항목 x를 삽입                                      |
  | `.remove(x)`    | 리스트 가장 왼쪽에 있는 항목(첫번째) x를 제거. 항목이 존재하기 않을 경우 `ValueError` |
  | `.pop()`        | 리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거                          |
  | `.pop(i)`       | 리스트의 인덱스 i에 있는 항목을 반환 후 제거                               |
  | `'.clear()`     | 리스트의 모든 항목 삭제                                            |

- 리스트 탐색 및 정렬 메서드
  
  | 메서드                    | 설명                                   |
  | ---------------------- | ------------------------------------ |
  | `.index(x)`            | 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환 |
  | `.count(x)`            | 리스트에서 항목 x의 개수 반환                    |
  | `.reverse()`           | 리스트의 순서를 역순으로 변경 (정렬 X)              |
  | `.sort(reverse=False)` | 리스트를 정렬 (매개변수 이용 가능)                 |

---

## 비시퀀스 데이터 구조

### 세트 set

    : 고유한 항목들의 정렬되지 않은 컬렉션

- 세트 메서드
  
  | 메서드                 | 설명                                 |
  | ------------------- | ---------------------------------- |
  | `.add(x)`           | 세트에 항목 x 추가. 이미 x가 있다면 변화 없음       |
  | `.clear()`          | 세트의 모든 항목 제거                       |
  | `.remove(x)`        | 세트에서 항목 x 제거. x가 없을 경우 `Key Error` |
  | `.pop()`            | 세트에서 랜덤하게 항목 반환하고, 해당 항목 제거        |
  | `.discard(x)`       | 세트에서 항목 x 제거                       |
  | `.update(iterable)` | 세트에 다른 iterable 요소 추가              |

- 세트의 집합 메서드
  
  | 메서드                   | 설명                                     | 연산자        |
  | --------------------- | -------------------------------------- | ---------- |
  | `s1.difference(s2)`   | s1에는 들어있지만 s2에는 없는 항목으로 세트 생성 후 반환     | `s1 - s2`  |
  | `s1.intersection(s2)` | s1과 s2 모두 들어있는 항목으로 세트 셍성 후 반환         | `s1 & s2`  |
  | `s1.issubset(s2)`     | s1의 항목이 모두 s2에 들어있으면 `True` 반환         | `s1 <= s2` |
  | `s1.isuperset(s2)`    | s1이 s2의 항목을 모두 포함하면 `True` 반환          | `s1 >= s2` |
  | `s1.union(s2)`        | s1 또는 s2에(혹은 둘 다) 들어있는 항목으로 세트 생성 후 반환 | `s1 \|     |

### 딕셔너리

- 딕셔너리 메서드
  
  | 메서드                 | 설명                                                                                         |
  | ------------------- | ------------------------------------------------------------------------------------------ |
  | `.clear()`          | 딕셔너리의 모든 키/값 쌍 제거                                                                          |
  | `.get(k)`           | 키 k에 연결된 값 반환 (키가 없으면 None 반환)                                                             |
  | `.get(k, v)`        | 키 k에 연결된 값을 반환하거나 키가 없으면 기본 값으로 v 반환                                                       |
  | `.keys()`           | 딕셔너리의 키를 모은 객체 반환                                                                          |
  | `.values()`         | 딕셔너리의 값을 모은 객체 반환                                                                          |
  | `.items()`          | 딕셔너리의 키/값 쌍을 모은 객체 반환                                                                      |
  | `.pop(k)`           | 딕셔너리에서 키 k를 제거하고, 연결됐던 값을 반환 (없으면 오류)                                                      |
  | `.pop(k, v)`        | 딕셔너리에서 키 k를 제거하고, 연결됐던 값을 반환 (없으면 v 반환)                                                    |
  | `.setdefault(k)`    | 딕셔너리에서 키 k와 연결된 값 반환                                                                       |
  | `.setdefault(k, v)` | 딕셔너리에서 키 k와 연결된 값 반환. k가 딕셔너리의 키가 아니라면 값 v와 연결한 키 k를 딕셔너리에 추가하고 v 반환                       |
  | `.update(other)`    | other 내 각 키에 대해 딕셔너리에 있는 키면 딕셔너리의 키 값을 other 값으로 대체. other에 있는 각 키에 대해 딕셔너리에 없다면 키/값 쌍을 추가 |

---

# 해시 테이블 Hash Table

: 해시 함수를 사용하여 변환한 값을 색인(index)으로 삼아 키(key)와 데이터(value)를 저장하는 자료구조

- 데이터 검색이 매우 빠르게 이루어지기 때문에 데이터를 효율적으로 저장하고 검색하기 위해 사용

- 원리
  
  - 키를 해시 함수를 통해 해시 값으로 변환하고, 이 해시 값을 인덱스로 사용하여 데이터를 저장하거나 검색

- ### 해시 Hash
  
  : 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것
  
  - 일종의 '지문'과 같은 역할을 하기 때문에 데이터를 고유하게 식별할 수 있음
  
  - 파이썬에서는 해시 함수를 사용해 데이터를 해시 값으로 변환하며, 이 해시 값은 정수로 표현됨

- ### 해시 함수 Hash Function
  
  : 임의의 길이의 데이터를 입력받아 고정된 길이의 데이터(해시 값)를 출력하는 함수. 파이썬이 재실행될 때마다 갱신됨
  
  - 주로 해시 테이블 자료구조에 사용되며, 매우 빠른 데이터 검색을 위한 컴퓨터 소프트웨어에서 유용하게 사용
  
  - 파이썬에서의 해시 함수
    
    - 파이썬에서 해시 함수의 동작 방식은 객체의 타입에 따라 달라짐
    
    - 정수와 문자열을 서로 다른 타입이며, 이들의 해시 값을 계산하는 방식도 다름
    
    - 같은 정수는 항상 같은 해시 값을 가짐. 해시 테이블에 정수를 저장할 때 효율적인 방법
    
    - 문자열은 가변적인 길이를 가지고 있고, 문자열에 포함된 각 문자들의 유니코드 코드 포인트 등을 기반으로 해시 값을 계산. 문자열의 해시 값은 실행시마다 다르게 계산됨

- set의 요소 & dictionary의 키와 해시 테이블 관계
  
  - 파이썬에서 set의 요소와 dictionary의 키는 해시 테이블을 이용하여 중복되지 않는 고유한 값을 저장함
  
  - set 내의 각 요소는 해시 함수를 통해 해시 값으로 변환되고, 이 해시 값을 기반으로 해시 테이블에 저장됨
  
  - dictionary의 키는 고유해야 하므로, 키를 해시 함수를 통해 해시 값으로 변환하여 ㅎ시 테이블에 저장
  
  - dictinary의 키는 매우 빠른 탐색 속도를 제공하며, 중복된 값을 허용하지 않음

- set의 pop 메서드의 결과와 해시 테이블의 관계
  
  - pop()은 set에서 임의의 요소를 제거하고 반환
  
  - '무작위'란 실행할 때마다 다른 요소를 얻는다는 의미의 '무작위'가 아닌 '임의'라는 의미
  
  - 해시 테이블에 나타나는 순서대로 반환하는 것

- ### 해시 테이브 Hash Table
  
  : hash() 함수의 인자로 전달해서 결과를 반환 받을 수 있는 객체
  
  - 대부분의 불변형 데이터타입은 Hash Table. 단, tuple의 경우 불변형이지만 해시 불가능한 객체를 참조할 때는 tuple 자체도 해시 불가능해짐
  
  - 해시 테이블의 키는 **불변**해야 함. 객체가 생성된 후에 그 값을 변경할 수 없어야 함.
  
  - 불변 객체는 해시 값이 변하지 않으므로 동일한 값에 대해 일관된 해시 값을 유지할 수 있음. 단 'hash 가능하다 != 불변하다'

- 가변형 객체가 hashable하지 않은 이유
  
  - 해시 테이블의 무결성 유지 불가
    
    : 값이 변경될 수 있기 때문에 동일한 객체에 대한 해시 값이 변경될 가능성이 있음. 
  
  - 해시 값의 일관성 유지 불가
    
    : 가변형 객체가 변경되면 해시 값이 변경되기 때문에, 같은 객체에 대한 서로 다른 해시 값이 반환될 수 있음

---

## 참고

- ### 파이썬 문법 규격
  
  - 파이썬은 확장 BNF 표기법 사용
  
  - #### BNF (Backus-Naur Form)
    
    : 프로그래밍 언어의 문법을 표기하기 위한 표기법
  
  - #### EBNF (Extended Backus-Naur Form)
    
    : BNF를 확장한 표기법. 메타 기호를 추가하여 더 간결하고 표현력이 강해진 형태
    
    > | 메타기호 | 의미       |
    > | ---- | -------- |
    > | `[]` | 선택적 요소   |
    > | `{}` | 0번 이상 반복 |
    > | `()` | 그룹화      |
  
  - BNF와 같은 표기법을 사용하는 이유
    
    : 서로 다른 프로그래밍 언어, 데이터 형식, 프로토콜 등의 문법을 통일하여 정의하기 위해
