# 스택 Stack

: 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료 구조

- 특성
  
  - 스택에 저장도니 자료는 선형 구조를 갖음
    
    - 선형 구조 : 자료 간의 관계가 1대1의 관계를 가짐
    
    - 비선형구조 : 자료 간의 관계가 1대N의 관계를 가짐 (ex. 트리)
  
  - 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있음
  
  - **LIFO(Last-In-First-Out)** : 마지막에 삽입한 자료를 가장 먼저 꺼냄

- 자료구조
  
  - 자료를 선형으로 저장할 저장소
  
  - 배열 사용 가능
  
  - 저장소 자체를 스택이라 부르기도 함
  
  - 스택에서 마지막 삽입된 원소의 위치를 `top`이라 부름

- 연산
  
  - `push` : 삽입. 저장소에 자료를 저장
  
  - `pop` : 삭제. 삽입한 자료의 역순으로 저장소에서 자료를 꺼냄
  
  - `isEmpty` : 스택이 공백인지 아닌지 확인
  
  - `peek` : 스택의 top에 있는 item(원소) 반환

- 구현
  
  - `push` 알고리즘
    
    : `append` 메소드를 통해 리스트의 마지막에 데이터 삽입
    
    ```python
    def push(item):
        s.append(item)
    ```
    
    ```python
    def push(item, size):
        global top
        top += 1
        if top == size:
            print('overflow!')
        else:
            stack[top] = item
    
    size = 10
    stack = [0] * size
    top = -1
    
    push(10, size)
    top += 1        # push(20)
    stack[top] = 20
    ```
  
  - `pop` 알고리즘
    
    ```python
    def pop():
        if len(s) == 0:
            # underflow
            return
        else:
            return s.pop()
    ```
    
    ```python
    def pop():
        global top
        if top == -1:
            print('underflow')
            return 0
        else:
            top -= 1
            return stack[top+1]
    
    print(pop())
    
    if top > -1:     # pop()
        top -= 1
        print(stack[top+1])
    ```

- 구현 고려사항
  
  - 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만, 스택의 크기를 변경하지 어렵다는 단점이 있음
  
  - 이를 해결하기 위해 저장소를 동적으로 할당해 스택을 구현함
  
  - 동적 연결리스트를 이용해 구현하면 구현이 복잡하다는 단점이 있지만 ,메모리를 효율적으로 사용한다는 장점이 있음

- 응용 - Fuction call
  
  > - 프로그램에서의 함수 호출과 복귀에 따른 수행 순서 관리
  > 
  > - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용해 수행순서 관리
  > 
  > - 함수 호출이 발생하며 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 수 복귀할 주소 등의 정보를 스택 프레임(stack frame)에 저장해 시스템 스택에 삽입
  > 
  > - 함수의 실행이 끝나면 시스템 스택의 top 원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
  > 
  > - 함수 호출과 복귀에 따라 이 과정을 반복해 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 됨

---

## 재귀 호출

: 필요한 함수가 자신과 같은 경우 자신을 다시 호출하는 구조

- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출 방식보다 재귀호출방식을 사용해 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성 가능

- 예시 - factorial
  
  > - n에 대한 factorial : 1부터 n까지의 모든 자연수를 곱하여 구하는 연산
  > 
  > - 마지막에 구한 하위 값을 이용해 상위 값ㅇ르 구하는 작업 반복

```python
def f(i, N, v):   # v 찾는 값
    if i == N:
        return 0
    elif arr[i] == v:
        return 1
    else:
        return f(i+1, N)
```

---

### 계산기

- 문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산할 수 있음

- 표기법
  
  - 중위 표기법 Infix notation
    
    : 연산자를 피연산자의 가운데 표기하는 방법
    
    - ex) a+b
  
  - 후위 표기법 Postfix notation
    
    : 연산자를 피연산자 뒤에 표기하는 방법
    
    - ex) ab+
      
      

- 문자열 수식 계산의 일반적 방법
  
  1. 중위 표기법의 수식을 후위 표기법으로 변경 (스택 이용)
     
     1. 수식의 각 연사자에 대해 우선순위에 따라 괄호를 사용해 다시 표현
     
     2. 각 연산자를 그에 대응하는 오른쪽 괄호 뒤로 이동
     
     3. 괄호 제거
     
     > ex) A * B - C / D
     > 
     > ( (A * B) - (C / D ) )  -> ((A B)* (C D)/ )* -> AB*CD/-
     
     - 스택 이용한 알고리즘
       
       1. 입력 받은 중위 표기식에서 토큰을 읽기
       
       2. 토큰이 피연산자면 토큰 출력
       
       3. 토큰이 연산자(괄호 포함)일 때
          
          - 토큰이 스택의 top에 저장되어 있는 연산자보다 우선선위가 높으면 스택에 push
          
          - 높지 않으면 스택 top의 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop한 후 토큰의 연산자를 push
          
          - top에 연산자 없으면 push
       
       4. 토큰이 오른쪽 괄호`)` 이면 스택 top에 왼쪽 괄호`(` 가 올 때까지 스택에 pop 연산을 수행하고 pop한 연산자를 출력. 왼쪽 괄호 만나면  pop만 하고 출력하지는 않음
       
       5. 중위 표기식에 더 읽을 것이 없다면 중지. 더 읽을 것이 있다면 1번부터 다시 반복
       
       6. 스택에 남아있는 연산자 모두 pop해 출력
       - 스택 밖의 왼쪽 괄호는 우선순위가 가장 높으며, 스택 안의 왼쪽 괄호는 우선 순위가 가장 낮음
         
         | 토큰    | In-coming priority | In-stack priority |
         | ----- | ------------------ | ----------------- |
         | `)`   | -                  | -                 |
         | `* /` | 2                  | 2                 |
         | `+ -` | 1                  | 1                 |
         | `(`   | 0                  | 3                 |
  
  2. 후위 표기법의 수식을 스택을 이용해 계산
     
     1. 피연산자를 만나면 스택에 push
     
     2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop해 연산하고, 연산 결과를 다시 스택에 push
     
     3. 수식 끝나면 마지막으로 스택을 pop해 출력
