# 동적 계획 Dynamic Programming

## 메모이제이션 Memoization

- 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해 매번 다시 계산하지 않도록 해 전체적인 실행속도를 빠르게 하는 기술

- 동적 계획법의 핵심

- 알고리즘
  
  ```python
  # memo를 위한 배열을 할당하고, 모두 0으로 초기
  # memo[0]을 0으로 memo[1]는 1로 초기화
  
  def fibo1(n):
      global memo
    if n >= 2 and memo[n] == 0:
        memo[n] = fibo1(n-1) + fibo1(n-2)
    return memo[n]
  
  memo = [0] * (n+1)
  memo[0] = 0
  memo[1] = 1
  ```

---

## 동적 계획 Dynamic Programming

: 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘

- 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후 그 해들을 이용해 보다 큰 크기의 부분 문제들을 해결해 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘

- 구현 방식
  
  - recursive 방식 : Memoization의 `fibo1()`
  
  - iterative 방식 : `fibo2()`
  
  - memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능 면에서는 보다 효율적
  
  - 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드 발생

- 예시 - 피보나치 수열
  
  > - 피보나치 수는 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있으므로 최적 부분 구조로 이루어짐
  > 1. 문제를 부분 문제로 분할
  >    
  >    - Fibonacci(n) 함수는 Fibonacci(n-1) + Fibonacci(n-2)
  >    
  >    - Fibonacci(n-1) = Fibonacci(n-2) + Fibonacci(n-3)
  >    
  >    - Fibonacci(n)은 Fibonacci(n-1), Fibonacci(n-2), ... Fibonacci(2), Fibonacci(1), Fibonacci(0)의 부분집합으로 나뉨
  > 
  > 2. 부분 문제로 나누는 일을 끝냈으면 가장 작은 부분 문제부터 해 구하기
  > 
  > 3. 그 결과는 테이블에 저장하고, 테이블에 저장된 부분 문제의해를 이용해 상위 문제의 해를 구함
  > 
  >     
  > 
  > | 테이블 인덱스 | [0] | [1] | [2] | [3] | ..  | [n]     |
  > | ------- | --- | --- | --- | --- | --- | ------- |
  > | 저장 값    | 0   | 1   | 1   | 2   | ..  | fibo(n) |
  > 
  > ```python
  > def fibo2(n):
  >     f = [0] * (n+1)
  >     f[0] = 0
  >     f[1] = 1
  >     for i in range(2, n+1):
  >         f[i] = f[i-1] + f[i-2]
  > 
  >     return f[n]
  > ```

- 예시 - 백준 11722번. 가장 긴 감소하는 부분 수열
  
  > - 문제
  >   
  >   - 수열 A가 주어졌을 때, 가장 긴 감소하는 부분 수열을 구하는 프로그램을 작성하시오.
  >   
  >   - 예를 들어, 수열 A = {10, 30, 10, 20, 20, 10} 인 경우에 가장 긴 감소하는 부분 수열은 A = {10, **30**, 10, **20**, 20, **10**}  이고, 길이는 3이다.
  > 
  > - 입력
  >   
  >   - 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.
  >   
  >   - 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)
  > 
  > - 출력
  >   
  >   - 첫째 줄에 수열 A의 가장 긴 감소하는 부분 수열의 길이를 출력한다.
  > 
  > - 예제 입력 1 복사
  > 
  >         6
  >         10 30 10 20 20 10
  > 
  > - 예제 출력 1 복사
  > 
  >         3
  > 
  > ```python
  > N = int(input())
  > lst = list(map(int, input().split()))
  > 
  > dp = [1] * N
  > 
  > for i in range(N):
  >     for j in range(0, i):
  >         if lst[i] < lst[j]:
  >             dp[i] = max(dp[i], dp[j]+1)
  > 
  > print(max(dp))
  > ```
