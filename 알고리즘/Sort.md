# 정렬

: 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열 하는 것

- 키
  
  : 자료를 정렬하는 기준이 되는 특정 값

- 대표적인 정렬 방식의 종류
  
  - 버블 정렬 (Bubble Sort)
  
  - 카운팅 정렬 (Counting Sort)
  
  - 선택 정렬 (Selection Sort)
  
  - 퀵 정렬 (Quick Sort)
  
  - 삽입 정렬 (Insertion Sort)
  
  - 병합 정렬 (Merge Sort)
  
  | 알고리즘   | 평균 수행시간    | 최악 수행시간    | 알고리즘 기법 | 비고                 |
  | ------ | ---------- | ---------- | ------- | ------------------ |
  | 버블 정렬  | O(n^2)     | O(n^2)     | 비교와 교환  | 코딩 제일 쉬움           |
  | 카운팅 정렬 | O(n+k)     | O(n+k)     | 비교환 방식  | n이 비교적 작은때만 가능     |
  | 선택 정렬  | O(n^2)     | O(n^2)     | 비교와 교환  | 교환 횟수가 버블, 삽입보다 작음 |
  | 퀵 정렬   | O(n log n) | O(n^2)     | 분할 정복   | 평균적으로 가장 빠름        |
  | 삽입 정렬  | O(n^2)     | O(n^2)     | 비교와 교환  | n 개수 작을 때 효과적      |
  | 병합 정렬  | O(n log n) | O(n log n) | 분할 정복   | 연결리스트의 경우 가장 효율적   |

- ![정렬시간복잡도비교](https://github.com/user-attachments/assets/71afb958-e5cc-4ac7-b4be-cfe54d4c2f19)

---

## 버블 정렬 Bubble Sort

: 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라 함

- 정렬 과정
  
  1. 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  
  2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
  
  3. 위 단계 반복

- 시간 복잡도 : **O(n^2)**

- 배열을 활용한 버블 정렬
  
  > ```pseudocode
  > BubbleSort(a, N)         # 정렬할 배열과 배열의 크기
  >   for i : N-1 -> 1       # 정렬할 구간의 끝
  >     for j : 0 -> i-1     # 비교할 원소 중 왼쪽 원소의 인덱스
  >       if a[j] > a[j+1]   # 왼쪽 원소가 더 크면
  >         a[j] <=> a[j+1]  # 오른쪽 원소와 교환
  > ```
  > 
  > ```python
  > def BubbleSort(a, N):          # 정렬할 List, N 원소 수
  >   for i in range(N-1, 0, -1):  # 범위의 끝 위치
  >     for j in range(0, i):      # 비교할 왼쪽 원소
  >       if a[j] > a[j+1]:
  >         a[j], a[j+1] = a[j+1], a[j]
  > ```

---

## 카운팅 정렬 Counting Sort

: 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

- 제한 사항
  
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    : 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 배열을 사용하기 때문
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내 가장 큰 정수를 알아야 함

> ```python
> def Counting_Sort(DATA, TEMP, k):
> # DATA [] -- 입력 배열 (0 to k)
> # TEMP [] -- 정렬된 배열
> # COUNTS [] -- 카운트 배열
> 
>   COUNTS = [0] * (k+1)
> 
>   for i in range(0, len(DATA)):
>     COUNTS[DATA[i]] += 1
>   for i in range(1, k+1):
>     COUNTS[i] += COUNTS[i-1]
>   for i in range(len(TEMP)-1, -1, -1):
>     COUNTS[DATA[i]] -= 1
>     TEMP[COUNTS[DATA[i]]] = DATA[i]
> ```

- 시간 복잡도 : **O(n+k)** (n은 리스트 길이, k는 정수의 최댓값)

- 예시 - [0, 4, 1, 3, 1, 2, 4, 1] 카운팅 정렬
  
  > - 1단계
  >   : Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스되는 카운트 배열 counts에 저장
  >   
  >   - Data : | 0 | 4 | 1 | 3 | 1 | 2 | 4 | 1 |
  >   
  >   - counts : | 0 | 0 | 0 | 0 | 0 | -> | 1 | 3 | 1 | 1 | 2 |
  > 
  > - 2단계
  >   
  >   : 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정한다. (앞 항목들 개수 더함)
  >   
  >   - counts : | 1 | 3 | 1 | 1 | 2 | -> | 1 | 4 | 5 | 6 | 8 |
  > 
  > - 3단계
  >   
  >   : counts[1]을 감소시키고 Temp에 1 삽입
  >   
  >   - Data : | 0 | 4 | 1 | 3 | 1 | 2 | 4 | 1<- J=7 |
  >   
  >   - counts : | 1 | 4->3 | 5 | 6 | 8 |
  >   
  >   - Data : |   |   |   | 1  |   |   |   |   |
  > 
  > - 4단계
  >   
  >   : counts[4]을 감소시키고 Temp에 4 삽입
  >   
  >   - Data : | 0 | 4 | 1 | 3 | 1 | 2 | 4<-J=6 | 1 |
  >   
  >   - counts : | 1 | 3 | 5 | 6 | 8->7 |
  >   
  >   - Data : |   |   |   | 1 |   |   |   | 4 |
  > 
  > - 5단계
  >   
  >   : counts[2]을 감소시키고 Temp에 2 삽입
  >   
  >   - Data : | 0 | 4 | 1 | 3 | 1 | 2<-J=5 | 4 | 1 |
  >   
  >   - counts : | 1 | 3 | 5->4 | 6 | 7 |
  >   
  >   - Data : |   |   |   | 1 |  2 |   |   | 4 |
  > 
  > - 6단계
  >   
  >   : counts[1]을 감소시키고 Temp에 1 삽입
  >   
  >   - Data : | 0 | 4 | 1 | 3 | 1<-j=4 | 2 | 4 | 1 |
  >   
  >   - counts : | 1 | 3->2 | 4 | 6 | 7 |
  >   
  >   - Data : |   |   | 1 | 1 |  2 |   |   | 4 |
  > 
  > - 7단계
  >   
  >   : counts[3]을 감소시키고 Temp에 3 삽입
  >   
  >   - Data : | 0 | 4 | 1 | 3<-j=3 | 1 | 2 | 4 | 1 |
  >   
  >   - counts : | 1 | 2 | 4 | 6->5 | 7 |
  >   
  >   - Data : |   |   | 1 | 1 | 2 | 3 |   | 4 |
  > 
  > - 8단계
  >   
  >   : counts[1]을 감소시키고 Temp에 1 삽입
  >   
  >   - Data : | 0 | 4 | 1<-j+2 | 3 | 1 | 2 | 4 | 1 |
  >   
  >   - counts : | 1 | 2->1 | 4 | 5 | 7 |
  >   
  >   - Data : |   | 1 | 1 | 1 | 2 | 3 |   | 4 |
  > 
  > - 9단계
  >   
  >   : counts[4]을 감소시키고 Temp에 4 삽입
  >   
  >   - Data : | 0 | 4<-j=1 | 1 | 3 | 1 | 2 | 4 | 1 |
  >   
  >   - counts : | 1 | 1 | 4 | 5 | 7->6 |
  >   
  >   - Data : |   | 1 | 1 | 1 | 2 | 3 | 4 | 4 |
  > 
  > - 10단계
  >   
  >   : counts[0]을 감소시키고 Temp에 0 삽입
  >   
  >   - Data : | 0<-j=0 | 4 | 1 | 3 | 1 | 2 | 4 | 1 |
  >   
  >   - counts : | 1->0 | 1 | 4 | 5 | 6 |
  > 
  > - Data : | 0 | 2 | 1 | 1 | 2 | 3 | 4 | 4 |
  > 
  > - 11단계
  >   
  >   : Temp 업데이트를 완료하고 정렬 작업을 종료

---

## 선택 정렬 Selection Sort

: 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택해 위치를 교환하는 방식

- 정렬 과정
  
  1. 주어진 리스트 중에서 최소값을 찾는다.
  
  2. 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
  
  3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.

> ```pseudocode
> def SelectionSort(a[], n)
>   for i from 0 to n-2
>     a[i], ..., a[n-1] 원소 중 최소값 a[k] 찾음
>     a[i]와 a[k] 교환
> ```
> 
> ```python
> def selectionSort(a, N):
>   for i in range(N-1):
>     min_idx = i
>     for j in range(i+1, N):
>       if a[j] < a[min_idx]:
>         min_idx = j
>     a[i], a[min_idx] = a[min_idx], a[i]
> ```
> 
> > 

- 시간 복잡도 : **O(n^2)**

- 예시 - [64, 26, 10, 22 ,11] 선택 정렬
  
  > 1. 주어진 리스트에서 최소값 찾는다. (10)
  >    
  >    | 64  | 25  | 10  | 22  | 11  |
  >    | --- | --- | --- | --- | --- |
  > 
  > 2. 리스트 맨 앞에 위치한 값과 교환한다.
  >    
  >    | 10  | 25  | 64  | 22  | 11  |
  >    | --- | --- | --- | --- | --- |
  > 
  > 3. 미정렬 리스트에서 최소값 찾는다. (11)
  >    
  >    | 10  | 25  | 64  | 22  | 11  |
  >    | --- | --- | --- | --- | --- |
  > 
  > 4. 리스트 맨 앞에 위치한 값과 교환한다.
  >    
  >    | 10  | 11  | 64  | 22  | 25  |
  >    | --- | --- | --- | --- | --- |
  > 
  > 5. 미정렬 리스트에서 최소값 찾는다. (22)
  >    
  >    | 10  | 11  | 64  | 22  | 25  |
  >    | --- | --- | --- | --- | --- |
  > 
  > 6. 리스트 맨 앞에 위치한 값과 교환한다.
  >    
  >    | 10  | 11  | 22  | 64  | 25  |
  >    | --- | --- | --- | --- | --- |
  > 
  > 7. 미정렬 리스트에서 최소값 찾는다. (25)
  >    
  >    | 10  | 11  | 22  | 64  | 25  |
  >    | --- | --- | --- | --- | --- |
  > 
  > 8. 리스트 맨 앞에 위치한 값과 교환한다.
  >    
  >    | 10  | 11  | 22  | 25  | 64  |
  >    | --- | --- | --- | --- | --- |
  > 
  > 9. 미정렬 원소가 하나 남은 상황에서는 마지막 원소가 가장 큰 값을 갖게 되므로, 실행을 종료하고 선택 정렬이 완료된다.

- #### 셀렉션 알고리즘 Selection Algorithm
  
  : 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
  
  : 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 함
  
  - 선택 과정
    
    1. 정렬 알고리즘을 이용하여 자료 정렬하기
    
    2. 원하는 순서에 있는 원소 가져오기
  
  - 예시 - k번째로 작은 원소 찾기
    
    > - 1번부터 k번째까지 작은 원소들을 찾아 배열의 앞쪽으로 이동시키고, 배열의 k번째를 반환
    > 
    > - k가 비교적 작을 때 유용하며, O(kn)의 수행시간을 필요로 함.
    > 
    > ```python
    > def select(arr, k):
    >   for i in range(0, k):
    >     min_index = i
    >     for j in range(i+1, len(arr)):
    >       if arr[j] < arr[min_index]:
    >         min_index = j
    >     arr[i], arr[min_index] = arr[min_index], arr[i]
    >   return arr[k-1]
    > ```
