# 문자열 String

- 코드 체계
  
  : 영어(대소문자 포함 52자)를 6비트(64가지)로 표현하는 것
  
  - 메모리는 숫자만을 저장할 수 있기 때문에 각 문자에 대응하는 숫자를 정해 놓고 이것을 메모리에 저장하는 방법 사용
  
  - 글자 모양 그대로 비트맵에 저장하는 방법은 메모리 낭비가 심해 사용하지 않음
  
  - #### ASCII
    
    - 1967년 미국에서 제정한 문자 인코딩 표준
    
    - 7-bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어짐
    
    - 출력 가능한 아스키 문자(32 ~ 126)
      
      ![출력가능아스키문자](https://github.com/user-attachments/assets/ef02f3af-0bb7-485f-9064-a7fbbfaef0bc)
  
  - #### 확장 아스키
    
    - 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호
    
    - 1 Byte 내의 8-bit를 모두 사용해 추가적인 문자 표현
  
  - #### 유니코드
    
    - 다국어 처리를 위한 표준
    
    - 자국의 코드체계를 타 국가가 가지고 있지 않으면 정보를 잘못 해석할 수 밖에 없기에 제정됨
    
    - Character Set으로 분류됨
      
      - UCS-2(Universal Character Set 2) / UCS-4(Universal Character Set 4)
      
      - 유니코드를 저장하는 변수의 크기를 정의했으나 바이트 순서에 대해 표준화하지 못함
      
      - 파일 인식 시 해당 파일이 UCS-2인지 UCS-4인지 인식하고 각 경우를 구분해 모두 다르게 구현해야 하는 문제 발생 -> 외부 인코딩의 필요성
    
    - 유니코드 인코딩 UTF(Unicode Transformation Format)
      
      - UTF-8 (in web) : MIN 8bit, MAX 32bit(1Byte*4)
      
      - UTF-16 (in windows, java) : MIN 16bit, MAX 32bit(2Byte*2)
      
      - UTF-32 (in unix) : MIN 32bit, MAX 32bit(4Byte*1)
    
    - big-endian, little-endian
  
  - Python 인코딩
    
    - 2.x 버전 : ASCII. `#-*-` coding은 ufg-8 `-8-` (첫 줄에 명시)
    
    - 3.x 버전 : 유니코드 UTF-8. 생략 가능
    
    - 다른 인코딩 방식으로 처리시 첫 줄에 작성하는 위 항목에 원하는 인코딩 방식을 지정해주면 됨
  
  - 데이터 저장 순서
    
    - Big Endian : 저장할 때 상위 바이트(큰 쪽) 먼저 저장
      
      - 대표 CPU : Sparc
      
      > ex) 00000000 00110000 = 0 0 3 0
    
    - Little Endian : 저장할 때 하위 바이트 먼저 저장
      
      - 대표 CPU : Intel
      
      > ex) 00110000 00000000 = 3 0 0 0
    
    - 다른 방식의 엔디안 사이의 통신에서는 읽고 쓰는 방법이 달라 문제가 됨
    
    - 네트워크에서는 빅 엔디안으로 통일

- 문자열의 분류
  
  ![문자열 분류](https://github.com/user-attachments/assets/f2dcf9e4-f3ce-417f-b1c1-f3283e5ff152)java에서 String 클래스에 대한 메모리 배치의 예시

- #### JAVA(객체지향 언어)에서의 문자열 처리
  
  - 유니코드(UTF16, 2byte)로 저장
  
  - 문자열 데이터를 저장, 처리해주는 클래스 제공
  
  - String 클래스 사용
    
    > ```java
    > String str = "abc";
    > String str = new String("abc")
    > ```
  
  - 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공
    
    > ```java
    > +, length(), replace(), split(), substring(), ...
    > ```
  
  - java.lang.String 클래스의 필드
    
    - 기본적인 객체 메타 데이터, hash값(hash), 문자열의 길이(count), 문자열 데이터의 시작점(offset), 실제 문자열 배열에 대한 참조(value) 
      ![java클래스필드](https://github.com/user-attachments/assets/6f845700-5fb1-4769-a307-74e4897c9560)

- #### C언어에서의 문자열 처리
  
  - 아스키코드로 저장
  
  - 문자열은 문자들의 배열 형태로 구현된 응용 자료형
  
  - 문자배열에 문자열을 저장할 때는 항상 마지막에 끝을 표시하는 널문자`\0`을 넣어줘야 함
    
    > ```c
    > char ary[] = {'a', 'b', 'c', '\0'}
    > char ary[] = "abc";
    > ```
  
  - 문자열 처리에 필요한 연산을 함수 형태로 제공
    
    > ```c
    > strlen(), strcpy(), strcmp(), ...
    > ```

- #### Python에서의 문자열 처리
  
  - 유니코드(UTF8)로 저장
  
  - char 타입 없음
  
  - 텍스트 데이터의 취급 방법이 통일되어 있음
  
  - 문자열은 시퀀스 자료형으로 분류됨. 인덱싱, 슬라이싱 연산들 사용 가능
  
  - 튜플과 같이 요소값 변경 불가능(Immutable)
  
  - 문자열 기호
    
    - `'(홑따옴표), "(쌍따옴표), '''(홑따옴표 3개), """(쌍따옴표 3개)`
    
    - `+` : 연결(Concatenation)
    
    - `*` : 반복
  
  - 문자열 클래스에서 제공되는 메소드
    
    > ```python
    > replace(), split(), isalpha(), find(), ...
    > ```

- C, JAVA, 파이썬 창
  
  > - C
  >   
  >   ```c
  >   char * name = "홍길동";
  >   int count = strlen(name);
  >   printf("%d", count);  # 6
  >   ```
  > 
  > - Java
  >   
  >   ```java
  >   String name = "홍길동";
  >   System.out.println(name.length());  # 3
  >   ```
  > 
  > - Python
  >   
  >   ```python
  >   name = "홍길동"
  >   print(len(name))  # 3
  >   ```

- 문자열 뒤집기
  
  - 자기 문자열에서 뒤집는 방법
    
    - swap을 위한 임시 변수 필요
    
    - 문자열 길이의 반만을 수행해야 함(정수 나눗셈)
  
  - 새로운 빈 문자열을 만들어 소스의 뒤에서부터 읽어서 타겟에 쓰는 방법

- 문자열 비교
  
  - C : `strcmp()`
  
  - Java : `equals()`
  
  - Python : `==`(내부적으로 특수 메서드 `__eq__()` 호출), `is`

- 문자열 숫자 -> 정수 변환
  
  - C : `atoi()`
    
    - 정수 -> 문자열 숫자 : `itoa()`
  
  - Java : 숫자 클래스의 `parse` 메소드
    
    - ex) `Integer.parseInt(String)`
    
    - 정수 -> 문자열 숫자 : `toString()` 메소드
  
  - Python : 숫자와 문자변환 함수 제공
    
    - ex) `int("123"), float("3.14"), str(123), repr(123)`

---

## 패턴 매칭 알고리즘

### 고지식한 알고리즘 Brute Force

   : 본문 문자열을 처음부터 끝까지 차례대로 순회하며 패턴 내의 문자들을 일일이 비교하는 방식

- 시간 복잡도 :최악의 경우 **O(MN)**

- 비교하다 틀리면 찾을 문자열의 인덱스는 처음으로, 전체 문자열의 인덱스는 한칸 뒤로
  
  > ```pseudocode
  >   > p = 'is'  # 찾을 패턴
  > t = "This is a book~!"  # 전체 텍스트
  > M = len(p)  # 찾을 패턴의 길이
  > N = len(t)  # 전체 텍스트의 길이
  > 
  > def BruteForce(p, t):
  >   i = 0  # t의 인덱스
  >   j = 0  # p의 인덱스
  >   while j < M and i < N:
  >     if t[i] != p[j]:
  >       i = i - j
  >       j = -1
  >     i += 1
  >     j += 1
  >   if j == M: return i - M  # 검색 성공
  >   else: return -1  # 검색 실패
  > ```

### KMP 알고리즘

  : 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭 수행

- 패턴을 전처리해 배열 `next[M]`을 구해 잘못된 시작을 최소화 함
  
  - `next[M]` : 불일치가 발생했을 경우 이동할 다음 위치
  
  - 패턴의 각 위치에 대해 매칭에 실패했을 때를 대비해 돌아갈 곳을 준비해둠

- 시간 복잡도 : **O(M+N) = O(N)**

- 예시
  
  > - 찾을 텍스트 `P[] = abcdabcef`
  > 
  > - 텍스트에서 `abcdabc`까지는 매치되고, `e`에서 실패한 상황
  > 
  > - 패턴의 맨 앞의 `abc`와 직전의 `abc`는 동일함 이용
  > 
  > - 실패한 텍스트 문자와 `P[4]` 비교
  > 
  > ![KMP1](https://github.com/user-attachments/assets/9e0516f2-0a7b-45e0-a65e-b1ea4a6c0baa)
  > ![KMP2](https://github.com/user-attachments/assets/9c1cd8cc-d9f2-4247-b5ce-16a0c3300463)

### 보이어-무어 알고리즘

  : 오른쪽에서 왼쪽으로 비교

- 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘

- 패턴에 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼이 됨

- 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재하는 경우, 패턴에서 일치하는 문자를 찾아 점프함

- 시간 복잡도 : **O(N)**
  ![보이어무어](https://github.com/user-attachments/assets/4abd02cc-62c6-42c2-adb6-2e90691d482e)

---

## 문자열 암호화

- 시저 암호 Caesar cipher
  
  : 줄리어스 시저(기원전 100년경 로마에서 활약했던 장군)가 사용했다고 하는 암호
  
  - 평문에서 사용되고 있는 알파벳을 일정한 문자 수만큼 **평행이동** 시킴으로써 암호화 행함
  
  - 예시 - 1만큼 평행
    
    > 평    문 : SAVE PRIVATE RYAN
    > 
    > 암호문 : TBWFAQSJWBUFASZBO
    > 
    > - 1만큼 평행했을 때, 키값은 1
  
  - 전사 공격
    
    - 키 값이 1, 2, 3... 25일 때 모두 대입

- 문자 변환표를 이용한 암호화(단일 치환 암호)
  
  - 단순한 카이사르 암호화보다 훨씬 강력한 암호화 기법
  
  - 복호화하기 위해서는 모든 키의 조합(key space)가 필요
  
  - 단일 치환 암호 키의 총 수는 26! = 403291461126605635584000000
  
  - 1초에 10억개의 키를 적용하는 속도여도 모든 키를 조사하는데 120억년 이상 필요

- bit열의 암호화
  
  : 배타적 논리함(exclusive-or) 연산 이용
  
  > 평    문 : 100110001110
  > 
  > 키         : 110001110011
  > 
  > 암호문 : 010111111101
