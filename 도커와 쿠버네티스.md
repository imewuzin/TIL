# 도커 / 쿠버네티스

- DevOps
  
  : 소프트웨어의 개발(Development)과 운영(Operation)을 결합한 소프트웨어 개발 방법론. 조직이 SW 제품과 서비스를 빠른 시간에 개발 및 배포하는 것을 목적으로 함
  
  - AWS, Docker, Kubernetes 등

- 프론트엔드
  
  : 고객이 사용하기 편리한 UI/UX를 브라우저를 통해 효과적으로 표현
  
  - React, Vue, Svelte 등

- 개발 프로세스
  
  1. Developer : 코드 작성
  
  2. Git : Merge, Request / Push
  
  3. CI : Test, Build
  
  4. CD : Deploy
  
  5. Server : Cloud
  
  6. Monitoring : Metrics(cpu, memory, ..), Log

---

## 서버를 관리하기 위한 노력

1. 자체 서버 운영
   
   - 서버 주문 > 서버 설치 > CPU, 메모리, 하드디스크 조립 > 네트워크 연결 > OS 설치 > 계정 설정 > 방화벽 설정 > ...
   
   - 서버를 설정하기 위해 많은 노력과 시간 필요
   
   - 성능이 좋은 걸 미리 구해하고 효율적인 사용을 위해 여러 애플리케이션 설치

2. 설정 관리 도구 등장 (CHEF, pippet, ANSIBLE 등)
   
   - 설정 파일을 관리해줌

3. 가상머신 등장
   
   - 너무 용량이 큼

4. 클라우드 등장
   
   - AWS, Google Cloud, Azure, ...
   
   - 하드웨어 파편화 문제 해결
   
   - 가상화된 환경만으로 아키텍처 구성이 가능해짐
   
   - 이미지를 기반으로한 다수의 서버 상태 관리
   
   - 상태 관리에 대한 새로운 접근이지만, 서버 운영의 문제는 여전히 그대로 남아있음

5. PaaS 등장
   
   - Vercel, Heroku, Netlify, AWS Elastic Beanstalk, Google Cloud app Engine, ...
   
   - 서버를 운영하는 것은 복잡하고 어려움
   
   - 잘 구성해 놓은 곳에 소스 코드만으로 배포
   
   - 일반화된 프로비저닝 방법을 제공 (프로비저닝 과정에 개입 불가)
   
   - 단점
     
     - 애플리케이션을 PaaS 방식에 맞게 작성해야함
     
     - 서버에 대한 원격 접속 시스템을 제공하지 않음
     
     - 서버에 파일 시스템을 사용할 수 없음
     
     - 서버 패키지를 설치할 수 없음
     
     - 로그 수집을 제한적인 방식으로 허용 (STDOUT)
     
     - 애플리케이션 배포에 대한 새로운 패러다임
   
   - PaaS에서 하기 어려운 것
     
     - 크론잡(문자 발송, 예약, 정산 등)
     
     - 데이터 분석(BigQuery, S3 등 연동)
     
     - 로그 분석(엘라스틱 서치, 스택드라이버, 클라우드와치 등)
     
     - 애플리케이션 성능 모니터링
     
     - A/B 테스트, Xanary 배포
     
     - 네트워크, 스토리지 설정

6. 도커 등장

7. 쿠버네티스 등장

8. 서비스메시 등장

---

## 도커와 쿠버네티스

- ### 도커 (Docker)
  
  : 컨테이너 기반 가장화 플랫폼. 응용 프로그램과 그 종속성을 격리된 환경인 컨테이너로 패키징하여 실행하는 기술
  
  : 어떠한 프로그램도 컨테이너로 만들 수 있고, 어디서든 돌아감
  
  : 2013년 DotClout(현 Docker)에서 첫 공개
  
  - **컨테이너** : 가상화 기술을 이용하여 어플리케이션과 개발 환경을 격리된 공간에서 실행하는 단위
  
  - 특징
    
    - 리눅스 커널의 여러 기술을 활용
    
    - 하드웨어 가상화 기술보다 가벼움
    
    - 이미지 단위로 프로세스 실행 환경을 구성
    
    - 가상머신처럼 독립적으로 실행되지만, 더 빠르고 쉽고 효율적임
  
  - **자원격리** 개념 사용
    
    - 프로세스, 파일, 디렉토리를 가상으로 분리함
    
    - CPU, Memory, I/O를 그룹별로 제한
    
    - 리눅스 기능을 이용한 빠르고 효율적인 서버 관리
  
  - 도커가 가져온 변화
    
    - 클라우드 이미지보다 관리하기 쉬움
    
    - 다른 프로세스와 격리되어 가상머신처럼 사용하지만, 성능저하 거의 없음
    
    - 복잡한 기술(namespace, cgroups, network, ...)을 몰라도 사용 가능
    
    - 이미지 빌드 기록이 남음
    
    - 코드와 설정으로 관리 > 재현 및 수정 가능
    
    - 오픈소스라 특정 회사 기술에 종속적이지 않음
  
  - 도커 이후의 개발 프로세스
    
    : Developer 코드 작성 -> Build -> Ship -> Run(Docker)
  
  - 도커 이후의 문제
    
    - 배포(Deploy) 관련
      
      - 각 서버에 들어가서 명령어를 실행해야 함
      
      - 서버의 여유 여부 관리 어려움
      
      - 롤아웃/롤백 손이 많이 감
    
    - 서비스 검색(Service Discovery) 관련
      
      - web 서버에 IP를 달아야 하는데, 일일이 써줘야 함
    
    - 서비스 노출(Gateway) 관련
      
      - 도메인별로 연결해주는 것 일일이 써줘야 함
    
    - 서비스 이상, 부하 모니터링 관련
      
      - 서버에 문제 생기면 바로 파악하고 조치해야하는데, 하나하나 들어가서 해야 함

- Container Orchestration
  
  : 복잡한 컨테이너 환경을 효과적으로 관리하기 위한 도구
  
  - Cluster : 중앙 제어 (master-node)
  
  - State(상태 관리) : 설정만 바꾸면 바꿔주기 + 관리
  
  - Scheduling(배포 관리) : 어느 서버에 들어가야할지 관리
  
  - Rollout/Rollback(배포 버전 관리) : 알아서 버전 바꿔줌
  
  - Service Discovery(서비스 등록 및 조회) : 자동으로 서비스 찾아 연결
  
  - Volume(볼륨 스토리지) : 용량 관리

- ### 쿠버네티스 (Kubernetes)
  
  : 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 오픈소스 플랫폼
  
  : 1주일에 20억개의 컨테이너를 생성하는 google이 컨테이너 배포 시스템으로 사용하던 borg를 기반으로 만든 오픈소스 v1.0 release(2015)
  
  - `kubectl` 명령어 이용
    
    - `get node`, `get namespace` 등으로 현재 node(서버), namespace 조회 가능
    
    - `get po -n monitoring` 으로 'monitoring'으로 배포된 상황 조회 가능
    
    - 버전, 현 상황, 로그 등 확인 가능
    
    - 오류 나도 알아서 처리해줌 -> 배포 시 오류 걱정 줄음
  
  - 특징
    
    - 무한한 확장성 : 머신러닝, CI/CD, 서비스메시, 서버리스
    
    - 컨테이너 오케스트레이션의 사실상의 표준 (de facto). Cloud native의 핵심 역할
  
  - 주요 기능
    
    - 배포: 지정된 수의 컨테이너를 지정된 호스트에 배포하고 원하는 상태로 계속 실행
    
    - 롤아웃: 배포를 변경하는 것 
    
    - 서비스 검색: DNS 이름 또는 IP 주소를 사용하여 컨테이너를 인터넷이나 다른 컨테이너에 자동으로 노출
    
    - 스토리지 프로비저닝: 필요에 따라 컨테이너에 대한 영구 로컬 또는 클라우드 스토리지를 마운트하도록 Kubernetes를 설정
    
    - 로드 밸런싱: CPU 사용률 또는 사용자 지정 메트릭을 기반으로 네트워크 전체에 워크로드를 분산하여 성능과 안정성 유지
    
    - 자동화된 복구 (self-healing): 어떤 노드나 컨테이너가 장애가 발생하면, 자동으로 해당 컨테이너를 복구하거나 새로운 컨테이너를 생성하여 문제 해결

---

## 배포 프로세스

- 배포 프로세스 고민
  
  - 배포를 더 자주 할 수 있을까? -> 더 작은 단위로 자주 배포하자
  
  - 배포를 더 빠르게 할 수 있을까? -> 소스를 푸시하면 자동으로 빌드하자
  
  - 배포를 더 많이 할 수 있을까? -> 테스트 서버 수를 늘리자
  
  - 배포를 더 자유롭게 할 수 있을까? -> 배포권한을 확대하자

- 2차 프로세스 개선
  
  - GitLab webhook + CI와 CD 분리
    
    - GitLab에 'Jenkins Build' 댓글을 달면 Jenkins가 배포해주는 방식 사용
    
    - 장점
      
      - 모든 브랜치는 자동으로 빌드되어 도커 이미지로 만들어짐
        
        - 바로 배포 가능한 도커 이미지가 항시 대기중
      
      - 테스트, QA를 하기 위해서 여러개의 서버 중 원하는 서버를 사용하고 완료되면 종료
        
        - 누가 몇 번 서버에서 어떤 브랜치를 테스트 중인지 Jenkins에서 확인
      
      - 진행 중인 테스트를 기다리지 않고 여러 개의 테스트를 동시에 진행하고 배포
        
        - 테스트 서버 2대 -> 5대
    
    - 단점
      
      - 종료 까먹으면 그 서버 못 찾음 등..
  
  - GitOps
    
    - Git이 서버 배포에 대한 설정 파일도 관리하게 해서 쿠버네티스에 연결
    
    - 쿠버네티스를 쉽게 사용할 수 있게 도와주는 'ArgoCD' 사용

---

## DevOps 엔지니어

- 역할
  
  - 서비스를 배포하고 지원 + 모니터링
  
  - 배포 파이프라인 구성
  
  - 더 자주 더 빠른 릴리스
  
  - Cloud (AWS, Google Cloud, Azure, ....) / Cloud Native
  
  - 컨테이너 (Docker, Kubernetes, ...)
  
  - 보안 Network, IAM, Service Mesh, ...
  
  - 장애 대응
  
  - IaC - 테라폼, ...
  
  - SRE - SLI, SLO, ...
  
  - 외부 서비스 - DataDog, NewRelic, ...

- [DevOps 로드맵](https://roadmap.sh/devops)

- 10주 DevOps 스터디 커리큘럼 (1회 이상 서비스 배포 경험 필요)
  
  1. Terraform을 이용하여 AWS VPC 만들기
  
  2. 도커(컨테이너)로 서버 관리하기
  
  3. 자동 빌드 & 자동 배포 (CI/CD)
  
  4. 배포 알림 / 채팅 봇 만들기
  
  5. 쿠버네티스와 함께하는 컨테이너 오케스트레이션
  
  6. AWS EKS 본격 설정
  
  7. 모니터링
  
  8. 로그 수집
  
  9. 배포 최적화
  
  10. 서비스메시 (+보안)

- 어떤 신입 DevOps 엔지니어를 원하는가?
  
  - 역량
  
  - 태도
  
  - 핏 : 우리 서비스를 사용하는 고객의 문제를 해결할 수 있는 사람
  
  - 이 회사에 지원한 이유는 무엇인가요? 에 대한 대답
    
    - 많이 배울 수 있을 것 같아요 -> 회사가 교육기관? 다 배우면 나가나?
    
    - 최근 서비스가 빠르게 성장하고 있습니다. 제가 가진 역량과 태도가 서비스에 기여할 수 있다고 생각합니다. 빠르게 성장하는 서비스와 함게 저도 성장하고 싶습니다. 새로운 방법을 찾고 문제 해결하는 것을 좋아하며, 귀사의 도전적인 문화가 제가 추구하는 가치와 부합합니다. -> 예시 답안. 말로만 하면 안 되고, 뒷받침하는 사례(프로젝트 경험 등)가 있어야 함
